# 문제: 전대프연 대회에서 문제를 푼 팀은 풍선을 받게 된다. 풍선은 사람이 직접 달아주기 때문에 자원 봉사자가 필요하다.
# 풍선은 방 A와 방 B에 보관되어 있다. 대회에 참가한 팀의 수는 총 N개이고, 앉아있는 자리는 서로 다르다. 어떤 팀은 방 A에 가깝고, 어떤 팀은 B에 더 가깝다.
# 각 팀에게 달아줘야 하는 풍선의 수와 방 A와 B로부터의 거리가 주어진다. 이때, 모든 풍선을 달아주는데 필요한 이동 거리의 최솟값을 출력한다. 대회에서 풍선을 달아주는 사람은 매우 많고, 풍선은 한 가지 색상을 여러 개 달아준다고 가정한다. 풍선을 달기 위해 이동해야하는 거리는 팀이 A와 B로부터 떨어진 거리와 같다. 풍선을 달아주는 사람은 한 번에 풍선 하나만 들고 이동할 수 있다.

# 입력: 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 팀의 수 N(1 ≤ N ≤ 1,000)과 방 A와 B에 보관되어있는 풍선의 수 A, B가 주어진다. (0 ≤ A, B ≤ 10,000)
# 다음 N개 줄에는 팀에게 달아줘야하는 풍선의 수 K와 방 A로부터 떨어진 거리 DA, B로부터 떨어진 거리 DB (0 ≤ DA, DB ≤ 1,000)가 주어진다. 풍선이 부족한 경우는 없다. 즉, Σi Ki ≤ A+B.
# 입력의 마지막 줄에는 0이 세 개 주어진다.

# 출력: 각 테스트 케이스에 대해서, 모든 팀에게 풍선을 달아주기 위해 필요한 이동 거리의 최솟값을 한 줄에 하나씩 출력한다. 이때, 풍선을 달아주고 방 A나 B로 돌아오는 거리는 포함하지 않는다. 즉, 방 A와 B에서 팀으로 이동하는 거리만 포함한다.

import sys
import heapq

# 0, 0, 0 입력을 받을때 까지 테스트 케이스 받아 줌
while(1):
    # 테스트 케이스 입력
    n, a, b = map(int, sys.stdin.readline().split())

    # 0, 0, 0 입력이 되면 끝냄
    if(n == 0 and a == 0 and b == 0):
        break

    # 결과 값
    result = 0
    # 우선순위 큐
    queue = []

    # 해당 테스트 케이스에 대한 입력 받아서 queue를 최대 힙으로 만들어 준다.
    for i in range(n):
        k, to_A, to_B = map(int, sys.stdin.readline().split())

        # A,B로 부터 떨어진 거리의 차이가 클수록 우선순위 큐에서 위에 위치하게 해준다.
        heapq.heappush(queue, [-abs(to_A - to_B), k, to_A, to_B])

    # 최대 힙에서 하나씩 꺼내면서 결과 값을 찾아낸다.
    while(queue):
        temp, tk, ta, tb = heapq.heappop(queue)

        if(ta < tb):
            if(tk <= a):
                result += (ta * tk)
                a -= tk
            else:
                result += (ta * a + tb * (tk - a))
                b -= (tk-a)
                a = 0
        else:
            if(tk <= b):
                result += (tb * tk)
                b -= tk
            else:
                result += (tb * b + ta * (tk - b))
                a -= (tk-b)
                b = 0

    print(result)
