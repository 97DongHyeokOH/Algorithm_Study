# 문제: 지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.
# 물은 다음과 같이 재분배 한다.
# 먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.
# 이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.
# 예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.

# 입력: 첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.

# 출력: 첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.

import sys

n, k = map(int, sys.stdin.readline().split())

# 물병에 들어갈 수 있는 물의 양을 저장해놓은 list
water = []
# 물병에 들어갈 수 있는 물의 양
temp = 1
# 물병을 추가하지 않고 최대한으로 모을 수 있는 물의 양 저장하는 list
result = []

# water를 채워 줌
while(temp < 100000000):
    water.append(temp)
    temp *= 2

# 2의 거듭제곱 중에서 가능한 가장 큰 거듭제곱만큼 n에서 뺴준다
# 반복하면서 n이 0이 되거나 k가 0이 된다면 while문을 탈출
# n에서 빼준 값을 result에 저장해 줌
while(n and k):
    for w in water:
        if(n < w):
            n -= (w//2)
            result.append(w//2)
            break
        elif(n == w):
            n = 0
            result.append(w)
            break

    k -= 1

# k가 양수가 되거나 n이 0이된다면 추가해야될 물병이 없어도 된다는 것을 의미
# 아니라면 result에서 가장 작게 저장된 물의 양에서 남은 n을 빼주면 그 값이 추가해야 되는 물병의 수
if(k > 0 or n == 0):
    print(0)
else:
    print(min(result) - n)
